## Устные задания:
### 1. Какой самый эффективный способ конкатенации строк?

Структура Buffer имплементирует метод WriteString, что может использоваться для эффективной конкатенации строк в базовый байтовый срез.

Нет нужды использовать данное решение всегда. Его следует применять, когда программа должна конкатенировать крупное число строк. К примеру, экспорт содержимого большого CSV-файла.

```golang
import (
	"bytes"
	"fmt"
)

func main() {
	strings := []string{"This ", "is ", "even ", "more ", "performant "}
	buffer := bytes.Buffer{}
	for _, val := range strings {
		buffer.WriteString(val)
	}

	fmt.Println(buffer.String())
}
```
### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы определяют поведение, то есть определяют и описывают конкретные методы, которые должны быть у какого-то другого типа. Также, при помощи интерфейсов в Go реализован полиморфизм - возможность функции принимать аргументы различных типов.
- Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода;
- Они облегчают использование в модульных тестах заглушек, вместо реальных объектов;
- Будучи архитектурным инструментом, интерфейсы помогают отвязывать части кодовой базы.

### 3. Чем отличаются RWMutex от Mutex?
RWMutex концептуально то же самое, что и Mutex: он защищает доступ к памяти. Тем не менее, RWMutex дает немного больше контроля над памятью. Можно запросить блокировку для чтения, и в этом случае будет предоставлен доступ, если блокировка не удерживается для записи.

Это означает, что произвольное число читателей может удерживать блокировку читателя, пока ничто другое не удерживает блокировку писателя.
```golang
func (c *counter) CountV1() int {
   c.Lock()
   defer c.Unlock()
   return c.count
}
func (c *counter) CountV2() int {
   c.RLock()
   defer c.RUnlock()
   return c.count
}
```
CountV2 не блокирует count если не было блокировок на запись.

### 4. Чем отличаются буферизированные и не буферизированные каналы?
**Небуферизированный канал** - это канал, который обязывает при подаче значения в него, ожидать считывание из канала. Если никто не читает из него, горутина заблокируется, пока не появится тот, кто вычтет это значение.

Неправильное использование небуферизированного канала может привести к deadlock, что, в свою очередь, может привести к утечке горутин.

**Буферизированный канал** - это канал, который может принимать не одно значение, до того как он залочится, а несколько.

### 5. Какой размер у структуры struct{}{}?
**0** байт

***Как проверить:***
```golang
import (
    "fmt"
    "unsafe"
)

type S1 struct {
    f1 int
}

func main() {
    s1 := S1{}
    s2 := struct{}{}

    fmt.Printf("s1 size: %v\n", unsafe.Sizeof(s1))
    fmt.Printf("s2 size: %v\n", unsafe.Sizeof(s2))
}
```
***Вывод:***
```bash
s1 size: 8
s2 size: 0
```

### 6. Есть ли в Go перегрузка методов или операторов?
В Go **нет** перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям.
```golang
func SearchInts(a []int, x int) bool
func SearchStrings(a []string, x string) bool
```
Иной подход — это использование интерфейсов. Для примера можно создать интерфейс и функцию для поиска:
```golang
type Slice interface {
    Len() int
    Get(int) interface{}
}

Search(slice Slice, x interface{}) bool
```
Теперь достаточно создать два типа:
```golang
type Ints []int
type Strings []string
```
И реализовать интерфейс в каждом из типов. После этого можно использовать поиск и по строкам и по числам:
```golang
var strings Strings = []string{"one", "two", "three"}
fmt.Println(Search(strings, "one")) // true
fmt.Println(Search(strings, "four")) // false

var ints Ints = []int{0, 1, 2, 3, 4, 5}
fmt.Println(Search(ints, 0)) // true
fmt.Println(Search(ints, 10)) // false
```
В Go также **нет** перегрузки операторов.

**Перегрузка операторов** — это способ, с помощью которого операторы могут выполнять операции, определенные пользователями. Операторы ведут себя в соответствии с переданными аргументами.

Например, в C++ оператор «+» может использоваться для объединения строк, а также сложения двух целых чисел. Значение «+» также может быть определено пользователем и изменено в соответствии с потребностями программы. В JavaScript операция типа '1' + 1 приведет к выводу строки "11" из-за более высокого приоритета строк. Такие определения недопустимы в Go, операторы работают строго и выполняют операции только с определенными типами данных аргументов.
### 7. В какой последовательности будут выведены элементы map[int]int?
***Пример:***
```golang
m[0]=1
m[1]=124
m[2]=281
```
При итерации по карте с помощью range цикла порядок итераций не указывается и не гарантируется, что он будет одинаковым от одной итерации к следующей. Если необходимо соблюдать стабильный порядок итераций, следует создать отдельную структуру данных, которая определяет этот порядок.

***Пример:***
```golang
import "sort"

var m map[int]int
var keys []int
for k := range m {
    keys = append(keys, k)
}
sort.Ints(keys)
for _, k := range keys {
    fmt.Println("Key:", k, "Value:", m[k])
}
```
### 8. В чем разница make и new?
**new()** выполняет обнуление, то есть создает тип со значением по умолчанию и возвращает указатель.

**make()** инициализирует map, slice или chan со значениями по умолчанию для каждого элемента и возвращает само значение, а не указатель.

***Пример:***
```golang
// аллоцирует структуру среза; *p == nil; используется редко
var p *[]int = new([]int)

// срез v теперь ссылается на новый массив из 100 int'ов
var v  []int = make([]int, 100)

// Излишне сложно:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Идиоматично:
v := make([]int, 100)
```
### 9. Сколько существует способов задать переменную типа slice или map?
Для того, чтобы создать переменную типа slice существует **5** способов:
```golang
var s []string
```
```golang
s := make([]string, 0)
```
```golang
s := []string{}
```
```golang
s := sl[:]
```
```golang
s := *new([]string)
```
Для того, чтобы создать переменную типа map существует **3** способа:
```golang
var m map[string]string
```
```golang
m := make(map[string]string)
```
```golang
m := *new(map[int]int)
```
### 10. Что выведет данная программа и почему?
```golang
func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```
***Вывод:***
```bash
1
1
```
Значение переменной **p** не меняется, потому что в функции **update** переменной **p** присваивается адрес переменной **b**, а после выхода из функции, значение этой переменной теряется.

Для того, чтобы добиться желаемого результата, необходимо указать, что по адресу переменной **p** теперь лежит значение переменной **b**:
```golang
func update(p *int) {
  b := 2
  *p = b
}
```
***Вывод:***
```bash
1
2
```
### 11. Что выведет данная программа и почему?
```golang
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```
Программа уходит в deadlock.

 **sync.WaitGroup{}** необходимо объявлять сразу по ссылке **&sync.WaitGroup{}**, потому что при первом его использовании в одной горутине, переменная **wg** теряется.

***Решение:***
```golang
func main() {
	wg := &sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```
### 12. Что выведет данная программа и почему?
```golang
func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
```
***Вывод:***
```bash
0
```
Это происходит потому, что внутри условия переменная **n** переобъявляется и переинициализируется, а **println** выводит значение переменной, объявленной вне условия.

***Решение:***
```golang
func main() {
	n := 0
	if true {
		n = 1
		n++
	}
	fmt.Println(n)
}
```
***Вывод:***
```bash
2
```
### 13. Что выведет данная программа и почему?
```golang
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```
***Вывод:***
```bash
[100 2 3 4 5]
```
При изменении элемента, программа работает все с тем же массивом, потому что слайс содержит указатель на этот массив.

При добавлении элемента, в связи с тем, что **capacity** переданного слайса равно 5, выделяется новая память и увеличивается **capacity** до 16. Из-за этого изменяется указатель на выделенную память. И по возвращению управления функции **main**, **println** выводит значения слайса по старому указателю.

***Решение:***
```golang
func someAction(v []int8, b int8) []int8 {
	v[0] = 100
	v = append(v, b)
	return v
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	a = someAction(a, 6)
	fmt.Println(a)
}
```
### 14. Что выведет данная программа и почему?
```golang
func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```
***Вывод:***
```bash
[b b a][a a]
```
При добавлении элемента, в связи с тем, что **capacity** переданного слайса равно 2, выделяется новая память и увеличивается **capacity** до 4. Из-за этого изменяется указатель на выделенную память. И по завершении работы анонимной функции, **println** выводит значения слайса по старому указателю.
***Решение:***
```golang
func main() {
	slice := []string{"a", "a"}

	slice = func(slice []string) []string {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
		return slice
	}(slice)
	fmt.Print(slice)
}
```
***Вывод:***
```bash
[b b a][b b a]
```
